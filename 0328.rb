問題
以下の要件を満たすbubble_sortメソッドを実装しましょう。
要素が数値である配列を受け取り、数値の小さい順に並べ替えること
小さい順に並べ替えた結果を出力すること

雛形
def bubble_sort(data)
  # 配列の数を数える処理を記述
  length = 

  # for文を2つ使用する
  # 先頭から隣の数同士の大きさを比べる
  # 先頭側の要素の方が大きい場合は、配列の位置を隣同士で交換する
end

呼び出し例
number = [1,23,4,6,12,45,79]
bubble_sort(number)
puts number

ヒント
・for文を使いましょう
for文は、指定された範囲や配列を順に変数に代入し、範囲や配列の要素の数だけ処理を繰り返して実行します。

・考え方を参考にしましょう
小さい順に数値を並べ替えていくアルゴリズムは複数あります。
今回は「隣同士の大きさを比較し、もし先頭側の文字の方が大きい場合は位置を交換する」という処理を、先頭から順に順に繰り返す考え方で実装しましょう。

・配列内の要素の入れ替え方を参考にしましょう
配列arrayのa番目とb番目の要素を入れ替えたいときは、以下のようにコードを記述します。
今回、「隣同士の大きさを比較し、もし先頭側の文字の方が大きい場合は位置を交換する」という処理を実装する際も同様のコードで記述してみましょう。

私の回答
def bubble_sort(data)
  length = data.length

  for i in 0..length-1
    for j in i..i+1
      if data[j] > data[j+1]
        data[j], data[j+1] = data[j+1], data[j]
        return data
      end
    end
  end
end

模範回答
def bubble_sort(data)
  length = data.length 
  for i in 0..(length-1) 
    for j in 1.. (length-i-1) 
      if data[j-1] > data[j] 
        data[j-1],data[j] = data[j],data[j-1] 
      end
    end
  end
end

解説
2行目で、配列dataの要素の数をカウントし、その結果を変数lengthに代入しています。

3行目の親のfor文では、配列dataの要素の数だけ処理が繰り返されるように設定しています。
変数iには、配列の要素の位置番号が順に代入されます。配列の要素は先頭を0番目とカウントするので「length(配列の要素の数)-1」となっていることに注意です。

4行目の子のfor文では、親のfor文の処理回数に関連して、処理が繰り返されるように設定しています。

親のfor文が1回目の時は、変数jに1から6までの数字が順に代入されていきます。(length-i-1)が、7(配列の数)-0(変数i)-1 = 6となるからです。
親のfor文が2回目の時は、変数jに1から5までの数字が順に代入されていきます。(length-i-1)が、7(配列の数)-1(変数i)-1 = 5となるからです。

繰り返し処理の内容について説明します。
5行目では、配列の先頭から順に隣同士の数の大きさを比較しています。if文は「隣同士の数を比べて、前の数の方が大きければ」という条件になっています。
6行目では、if文の条件に当てはまった場合のみ、配列の位置を交換しています。

感想
私の回答だと処理が1回きりで終わってしまって、かつreturn dataで返してしまっていた。
模範回答では、まず親のfor文1回目で隣同士を比べて並べ替え、さらに2回目のfor文でもう一度隣同士を並べ替えるということをしている。
分かりやすく、具体的な数字を入れて考えてみる。

def bubble_sort(data)
  length = data.length 
  for i in 0..(length-1) 
    for j in 1.. (length-i-1) 
      if data[j-1] > data[j] 
        data[j-1],data[j] = data[j],data[j-1] 
      end
    end
  end
end
number = [1,23,4,6,12,45,79]

親for1回目 i=0
子のforは、for j in 1..(7-0-1)
子for1回目 j=1 data[0]の1とdata[1]の23を比較→そのまま
子for2回目 j=2 data[1]の23とdata[2]の4を比較→チェンジ
.........
子for6回目 j=6 data[5]とdata[6]を比較
1回目終わり
ここまででdata[6]が一番大きい数字となることが確定しました

親for2回目 i=1
子のforは、for j in 1..(7-1-1)
子for1回目 j=1 data[0]とdata[1]を比較
子for2回目 j=2 data[1]とdata[2]を比較
.........
子for5回目 j=5 data[4]とdata[5]を比較
2回目終わり
ここまででdata[5]が二番目に大きい数字となることが確定しました

なるほど、仕組みがわかりました




